########### Kubernetes using ansible #############

You got it. Here is a simple Ansible playbook designed to **deploy a basic Kubernetes cluster** (using `kubeadm`) on a set of target nodes.

This playbook is structured into three main roles: **Common**, **Master**, and **Worker**.

### Playbook: `deploy_k8s.yml`

```yaml
---
- name: 🚀 Kubernetes Cluster Deployment - Common Setup
  hosts: all
  become: true
  roles:
    - k8s_common

- name: 🧠 Initialize Kubernetes Master Node
  hosts: master_nodes
  become: true
  roles:
    - k8s_master

- name: 🛠️ Join Worker Nodes to the Cluster
  hosts: worker_nodes
  become: true
  roles:
    - k8s_worker
```

-----

### 1\. Common Role: `roles/k8s_common/tasks/main.yml`

This task ensures the prerequisites (container runtime, necessary packages, and system settings) are met on *all* nodes.

```yaml
# tasks/main.yml for k8s_common role

- name: Update apt cache and install required packages
  ansible.builtin.apt:
    name: ['apt-transport-https', 'ca-certificates', 'curl', 'gnupg-agent', 'software-properties-common', 'kubelet', 'kubeadm', 'kubectl']
    state: present
    update_cache: true
    allow_unauthenticated: true

- name: Add Docker GPG key (as a Container Runtime is needed)
  ansible.builtin.apt_key:
    url: https://download.docker.com/linux/ubuntu/gpg
    state: present

- name: Add Docker repository
  ansible.builtin.apt_repository:
    repo: deb [arch=amd64] https://download.docker.com/linux/ubuntu focal stable
    state: present

- name: Install Docker
  ansible.builtin.package:
    name: docker-ce
    state: present

- name: Disable swap for kubelet
  ansible.posix.mount:
    name: swap
    fstype: swap
    state: absent
  # Use 'shell' to ensure swap is immediately disabled on running system
- name: Turn off swap immediately
  ansible.builtin.command: swapoff -a
  when: ansible_swaptotal_mb > 0
  changed_when: false # This command should not report a change on every run

- name: Load kernel modules and configure sysctl for K8s networking
  ansible.builtin.block:
    - name: Load overlay and br_netfilter kernel modules
      ansible.builtin.community.general.modprobe:
        name: "{{ item }}"
        state: present
      loop:
        - overlay
        - br_netfilter

    - name: Configure sysctl settings for Kubernetes networking
      ansible.builtin.sysctl:
        name: "{{ item.name }}"
        value: "{{ item.value }}"
        state: present
        reload: true
      loop:
        - { name: 'net.bridge.bridge-nf-call-iptables', value: '1' }
        - { name: 'net.ipv4.ip_forward', value: '1' }
```

-----

### 2\. Master Role: `roles/k8s_master/tasks/main.yml`

This role initializes the cluster and sets up the CNI and Kubeconfig.

```yaml
# tasks/main.yml for k8s_master role

- name: Initialize the Kubernetes control plane
  ansible.builtin.command: >
    kubeadm init --pod-network-cidr=10.244.0.0/16
    --apiserver-advertise-address={{ ansible_default_ipv4.address }}
  register: kubeadm_init_output
  changed_when: kubeadm_init_output.rc == 0
  args:
    creates: /etc/kubernetes/admin.conf

- name: Create .kube directory for the current user
  ansible.builtin.file:
    path: $HOME/.kube
    state: directory
    owner: "{{ ansible_user }}"
    mode: '0755'

- name: Copy admin.conf to user's .kube directory
  ansible.builtin.copy:
    src: /etc/kubernetes/admin.conf
    dest: $HOME/.kube/config
    remote_src: true
    owner: "{{ ansible_user }}"
    group: "{{ ansible_user }}"
    mode: '0644'

- name: Get the kubeadm join command and save it to a local file
  ansible.builtin.shell: kubeadm token create --print-join-command
  register: join_command_raw
  delegate_to: localhost

- name: Save join command to a local file
  ansible.builtin.copy:
    content: "{{ join_command_raw.stdout_lstrip }}"
    dest: "./kube_join_command"
    mode: '0644'
  delegate_to: localhost
  run_once: true

- name: Deploy Calico CNI (Flannel/Weave could also be used)
  ansible.builtin.command: kubectl apply -f https://docs.projectcalico.org/manifests/calico.yaml
  register: cni_output
  changed_when: cni_output.rc == 0
  ignore_errors: true # Ignore if CNI is already deployed
```

-----

### 3\. Worker Role: `roles/k8s_worker/tasks/main.yml`

This role reads the join command from the file created by the master and executes it on the worker nodes.

```yaml
# tasks/main.yml for k8s_worker role

- name: Read the join command from local file
  ansible.builtin.slurp:
    src: ./kube_join_command
  register: join_command_slurp
  delegate_to: localhost
  run_once: true

- name: Extract the join command content
  ansible.builtin.set_fact:
    join_command: "{{ join_command_slurp['content'] | b64decode }}"

- name: Join the worker node to the cluster
  ansible.builtin.command: "{{ join_command }}"
  register: join_result
  changed_when: join_result.rc == 0
  ignore_errors: true # Ignore if node is already joined
```

### Required Inventory File Structure

To run this playbook, you need an Ansible inventory file (e.g., `inventory.ini`) that defines your nodes and groups them into `master_nodes` and `worker_nodes`.

```ini
[master_nodes]
k8s-master ansible_host=192.168.1.10

[worker_nodes]
k8s-worker-1 ansible_host=192.168.1.11
k8s-worker-2 ansible_host=192.168.1.12

[all:vars]
ansible_user=your_ssh_user_name
```

**Execution Command:**

```bash
ansible-playbook -i inventory.ini deploy_k8s.yml
```
